From 9a8f8fe6548183bf51a2b4b6acee18235dd701f8 Mon Sep 17 00:00:00 2001
From: Kenneth Giusti <kgiusti@gmail.com>
Date: Fri, 3 Oct 2014 16:32:06 -0400
Subject: [PATCH] Provide better detection of failures during message send

This change causes the message sender to block until the peer
communicates the outcome of the sent message.  If the message is
accepted by the peer, then the sender will either pend for a response
(RPC), or simply return (notification).  If the send should fail or be
rejected by the peer a MessagingException will be raised at the
sender.

Change-Id: I3f4a1ed1c17e18f6d629f16e6b5c99de45b083d6
Closes-Bug: #1377228
---
 .../_drivers/protocols/amqp/controller.py          | 49 +++++++++++++++---
 oslo/messaging/_drivers/protocols/amqp/driver.py   | 58 +++++++++++++---------
 tests/test_amqp_driver.py                          | 20 ++++++--
 3 files changed, 90 insertions(+), 37 deletions(-)

diff --git a/oslo/messaging/_drivers/protocols/amqp/controller.py b/oslo/messaging/_drivers/protocols/amqp/controller.py
index 2550178..1dab2bd 100644
--- a/oslo/messaging/_drivers/protocols/amqp/controller.py
+++ b/oslo/messaging/_drivers/protocols/amqp/controller.py
@@ -34,6 +34,7 @@ import pyngus
 from six import moves
 
 from oslo.config import cfg
+from oslo import messaging
 from oslo.messaging._drivers.protocols.amqp import eventloop
 
 LOG = logging.getLogger(__name__)
@@ -131,6 +132,15 @@ class Replies(pyngus.ReceiverEventHandler):
         request.reply_to = self._receiver.source_address
         LOG.debug("Reply for msg id=%s expected on link %s",
                   request.id, request.reply_to)
+        return request.id
+
+    def cancel_response(self, msg_id):
+        """Abort waiting for a response message.  This can be used if the
+        request fails and no reply is expected.
+        """
+        reply_queue = self._correlation.get(msg_id)
+        if reply_queue is not None:
+            del self._correlation[msg_id]
 
     # Pyngus ReceiverLink event callbacks:
 
@@ -165,7 +175,9 @@ class Replies(pyngus.ReceiverEventHandler):
         key = message.correlation_id
         if key in self._correlation:
             LOG.debug("Received response for msg id=%s", key)
-            self._correlation[key].put(message)
+            result = {"status": "OK",
+                      "response": message}
+            self._correlation[key].put(result)
             # cleanup (only need one response per request)
             del self._correlation[key]
         else:
@@ -347,17 +359,35 @@ class Controller(pyngus.ConnectionEventHandler):
 
     # methods executed by Tasks created by the driver:
 
-    def request(self, target, request, reply_queue=None):
+    def request(self, target, request, result_queue, reply_expected=False):
         """Send a request message to the given target, and arrange for a
         response to be put on the optional reply_queue if specified
         """
         address = self._resolve(target)
         LOG.debug("Sending request for %s to %s", target, address)
-        if reply_queue is not None:
-            self._replies.prepare_for_response(request, reply_queue)
-        self._send(address, request)
+        if reply_expected:
+            msg_id = self._replies.prepare_for_response(request, result_queue)
+
+        def _callback(link, handle, state, info):
+            if state == pyngus.SenderLink.ACCEPTED:  # message received
+                if not reply_expected:
+                    # need wake up the sender
+                    result = {"status": "OK"}
+                    result_queue.put(result)
+            else:  # send failed/rejected/etc
+                msg = "Message send failed: remote disposition: %s, info: %s"
+                exc = messaging.MessagingException(msg % (state, info))
+                result = {"status": "ERROR", "error": exc}
+                if reply_expected:
+                    # no response will be received, so cancel the correlation
+                    self._replies.cancel_response(msg_id)
+                result_queue.put(result)
+        self._send(address, request, _callback)
 
     def response(self, address, response):
+        """Send a response message to the client listening on 'address'.  The
+        response is send asynchronously - the caller is not blocked.
+        """
         LOG.debug("Sending response to %s", address)
         self._send(address, response)
 
@@ -409,11 +439,14 @@ class Controller(pyngus.ConnectionEventHandler):
             self._senders[address] = sender
         return sender
 
-    def _send(self, addr, message):
-        """Send the message out the link addressed by 'addr'."""
+    def _send(self, addr, message, callback=None, handle=None):
+        """Send the message out the link addressed by 'addr'.  If a
+        delivery_callback is given it will be invoked when the send has
+        completed (whether successfully or in error).
+        """
         address = str(addr)
         message.address = address
-        self._sender(address).send(message)
+        self._sender(address).send(message, delivery_callback=callback)
 
     def _server_address(self, target):
         return self._concatenate([self.server_request_prefix,
diff --git a/oslo/messaging/_drivers/protocols/amqp/driver.py b/oslo/messaging/_drivers/protocols/amqp/driver.py
index b15c972..1ea526d 100644
--- a/oslo/messaging/_drivers/protocols/amqp/driver.py
+++ b/oslo/messaging/_drivers/protocols/amqp/driver.py
@@ -80,35 +80,44 @@ LOG = logging.getLogger(__name__)
 
 
 class SendTask(controller.Task):
-    """A task that sends a message to a target, and optionally allows for the
-    calling thread to wait for a reply.
+    """A task that sends a message to a target, and optionally waits for a
+    reply message.  The caller may block until the remote confirms receipt or
+    the reply message has arrived.
     """
-    def __init__(self, target, request, reply_expected, deadline):
+    def __init__(self, target, request, wait_for_reply, deadline):
         super(SendTask, self).__init__()
         self._target = target
         self._request = request
         self._deadline = deadline
-        if reply_expected:
-            self._reply_queue = moves.queue.Queue()
-        else:
-            self._reply_queue = None
+        self._wait_for_reply = wait_for_reply
+        self._results_queue = moves.queue.Queue()
+
+    def wait(self, timeout):
+        """Wait for the send to complete, and, optionally, a reply message from
+        the remote.  Will raise MessagingTimeout if the send does not complete
+        or no reply is received within timeout seconds. If the request has
+        failed for any other reason, a MessagingException is raised."
+        """
+        try:
+            result = self._results_queue.get(timeout=timeout)
+        except moves.queue.Empty:
+            if self._wait_for_reply:
+                reason = "Timed out waiting for a reply."
+            else:
+                reason = "Timed out waiting for send to complete."
+            raise messaging.MessagingTimeout(reason)
+        if result["status"] == "OK":
+            return result.get("response", None)
+        raise result["error"]
 
     def execute(self, controller):
         """Runs on eventloop thread - sends request."""
         if not self._deadline or self._deadline > time.time():
-            controller.request(self._target, self._request, self._reply_queue)
+            controller.request(self._target, self._request,
+                               self._results_queue, self._wait_for_reply)
         else:
             LOG.warn("Send request to %s aborted: TTL expired.", self._target)
 
-    def get_reply(self, timeout):
-        """Retrieve the reply."""
-        if not self._reply_queue:
-            return None
-        try:
-            return self._reply_queue.get(timeout=timeout)
-        except moves.queue.Empty:
-            raise messaging.MessagingTimeout('Timed out waiting for a reply')
-
 
 class ListenTask(controller.Task):
     """A task that creates a subscription to the given target.  Messages
@@ -133,7 +142,10 @@ class ListenTask(controller.Task):
 
 
 class ReplyTask(controller.Task):
-    """A task that sends 'response' message to address."""
+    """A task that sends 'response' message to 'address'.  Responses are sent
+    without blocking the sender to prevent a single badly behaving RPC client
+    from blocking the whole RPC server.
+    """
     def __init__(self, address, response, log_failure):
         super(ReplyTask, self).__init__()
         self._address = address
@@ -276,16 +288,14 @@ class ProtonDriver(base.BaseDriver):
         LOG.debug("Send to %s", target)
         task = SendTask(target, request, wait_for_reply, expire)
         self._ctrl.add_task(task)
-        result = None
-        if wait_for_reply:
-            # the following can raise MessagingTimeout if no reply received:
-            reply = task.get_reply(timeout)
+        reply = task.wait(timeout)
+        if reply:
             # TODO(kgiusti) how to handle failure to un-marshal?  Must log, and
             # determine best way to communicate this failure back up to the
             # caller
-            result = unmarshal_response(reply, self._allowed_remote_exmods)
+            reply = unmarshal_response(reply, self._allowed_remote_exmods)
         LOG.debug("Send to %s returning", target)
-        return result
+        return reply
 
     @_ensure_connect_called
     def send_notification(self, target, ctxt, message, version,
diff --git a/tests/test_amqp_driver.py b/tests/test_amqp_driver.py
index 7df6eb1..84fa6eb 100644
--- a/tests/test_amqp_driver.py
+++ b/tests/test_amqp_driver.py
@@ -262,14 +262,21 @@ class TestAmqpNotification(_AmqpBrokerTestCase):
 
         listener = _ListenerThread(nl, 3)
         targets = ['topic-1.info',
-                   'topic-1.bad',  # should be dropped
-                   'bad-topic.debug',  # should be dropped
+                   'topic-1.bad',  # will raise MessagingException
+                   'bad-topic.debug',  # will raise MessagingException
                    'topic-1.error', 'topic-2.debug']
 
+        excepted_targets = []
+        exception_count = 0
         for t in targets:
-            driver.send_notification(messaging.Target(topic=t),
-                                     "context", {'target': t},
-                                     1.0)
+            try:
+                driver.send_notification(messaging.Target(topic=t),
+                                         "context", {'target': t},
+                                         1.0)
+            except messaging.MessagingException:
+                exception_count += 1
+                excepted_targets.append(t)
+
         listener.join(timeout=30)
         self.assertFalse(listener.isAlive())
         topics = [x.message.get('target') for x in listener.get_messages()]
@@ -277,6 +284,9 @@ class TestAmqpNotification(_AmqpBrokerTestCase):
         self.assertTrue('topic-1.error' in topics)
         self.assertTrue('topic-2.debug' in topics)
         self.assertEqual(self._broker.dropped_count, 2)
+        self.assertEqual(exception_count, 2)
+        self.assertTrue('topic-1.bad' in excepted_targets)
+        self.assertTrue('bad-topic.debug' in excepted_targets)
         driver.cleanup()
 
 
